{
  "version": 3,
  "sources": ["../../../../../node_modules/@cfpb/cfpb-analytics/src/cfpb-analytics.js", "../../../../unprocessed/apps/analytics-gtm/js/event-listener-scroll-tracking.js"],
  "sourcesContent": ["/**\n * Log a message to the console if the `debug-gtm` URL parameter is set.\n * @param {string} msg - Message to load to the console.\n */\nfunction analyticsLog(...msg) {\n  // Check if URLSearchParams is supported (Chrome > 48; Edge > 16).\n  if (typeof window.URLSearchParams === 'function') {\n    // Get query params.\n    const queryParams = new URLSearchParams(window.location.search);\n    if (queryParams.get('debug-gtm') === 'true') {\n      // eslint-disable-next-line no-console\n      console.log(`ANALYTICS DEBUG MODE: ${msg}`);\n    }\n  }\n}\n\nlet loadTryCount = 0;\n\n/**\n * @returns {boolean} Whether GTM has been loaded or not.\n */\nfunction _isGtmLoaded() {\n  window.dataLayer = window.dataLayer || [];\n  const gtmStartedEvent = window.dataLayer.find(\n    (element) => element['gtm.start'],\n  );\n\n  if (!gtmStartedEvent) {\n    // Not even the GTM inline config has executed.\n    return false;\n  } else if (!gtmStartedEvent['gtm.uniqueEventId']) {\n    // GTM inline config has run, but the main GTM JS has not loaded.\n    return false;\n  }\n\n  // GTM is fully loaded and working.\n  return true;\n}\n\n/**\n * Poll every 0.5 seconds for 10 seconds for if Google Tag Manager has loaded.\n * @returns {Promise} Resolves if Google Tag Manager has loaded.\n *   Rejects if polling has completed.\n */\nfunction ensureGoogleTagManagerLoaded() {\n  return new Promise(function (resolve, reject) {\n    (function waitForGoogleTagManager() {\n      if (_isGtmLoaded()) return resolve();\n      if (++loadTryCount > 9) return reject();\n      setTimeout(waitForGoogleTagManager, 500);\n    })();\n  });\n}\n\n/**\n * @name analyticsSendEvent\n * @kind function\n * @description\n *   Pushes an event to the GTM dataLayer.\n *   This can accept arbitrary values, but traditionally (pre-GA4) would accept\n *   event, action, and label. Th eventCallback and eventTimeout values can also\n *   be sent, which are called if there's an issue loading GTM.\n * @param {object} payload - A list or a single event.\n * @param {string} payload.event - Type of event.\n * @param {string} payload.action - Name of event.\n * @param {string} payload.label - DOM element label.\n * @param {Function} [payload.eventCallback] - Function to call on GTM submission.\n * @param {number} [payload.eventTimeout] - Callback invocation fallback time.\n * @returns {Promise} Resolves if the event is sent,\n *   otherwise calls the callback if provided.\n */\nfunction analyticsSendEvent(payload) {\n  return ensureGoogleTagManagerLoaded()\n    .then(() => {\n      // GTM should be loaded at this point.\n      const printPayload = [];\n      Object.entries(payload).forEach(([key, value]) => {\n        printPayload.push(`(${key}: ${value})`);\n      });\n\n      analyticsLog(`Sending \"${printPayload.join(', ')}\"`);\n      window.dataLayer.push(payload);\n    })\n    .catch(() => {\n      if (\n        payload.eventCallback &&\n        typeof payload.eventCallback === 'function'\n      ) {\n        // eslint-disable-next-line callback-return\n        payload.eventCallback();\n      }\n    });\n}\n\nexport { analyticsSendEvent, analyticsLog };\n", "import { analyticsLog } from '@cfpb/cfpb-analytics';\n\n// Default time delay before checking location.\nconst callBackTime = 100;\n\n// Number of pixels before tracking a reader.\nconst readerLocation = 200;\n\n// Set some flags for tracking & execution.\nlet timer = 0;\nlet hasStartScroll = false;\n\n/* Threshold of pixels at bottomPos when 100% triggers.\n   For some reason some monitors were found to be a pixel off when scrolling to the bottomPos,\n   this gives a little wiggle-room for when the 100% event fires\n   so that it'll be 5px or less from the bottomPos. */\nconst threshold = 5;\n\nconst viewableHeight = window.innerHeight;\nconst totalheight = document.body.offsetHeight - threshold;\nconst totalHiddenHeight = totalheight - viewableHeight;\n\n// This will record events so they only fire once.\nconst hasFired = {};\n\n// This will store the y-position of the breakpoints at which to fire events.\nconst yPosCache = {};\n\n// Set some time variables to calculate reading time.\nconst startTime = new Date();\nconst timeAtPageLoad = startTime.getTime();\n\n/**\n * @returns {number} Seconds that have elapsed since the page load time.\n */\nfunction getTimeStamp() {\n  const currentTime = new Date();\n  return Math.round((currentTime.getTime() - timeAtPageLoad) / 1000);\n}\n\n/**\n * [trackSpecificLocation description]\n * @param {number} bottomPos - Number of pixels from the top of the page\n *   to current scroll top position.\n * @param {number} percent - Percent of the scrollable height to fire from.\n */\nfunction trackSpecificLocation(bottomPos, percent) {\n  let yPos = yPosCache[percent];\n\n  if (!yPos) {\n    const percentAsDecimal = percent / 100;\n    yPos = totalHiddenHeight * percentAsDecimal + viewableHeight;\n    yPosCache[percent] = yPos;\n  }\n\n  const hasFiredID = `hit${percent}`;\n\n  if (!hasFired[hasFiredID] && bottomPos >= yPos) {\n    const timeToContentEnd = getTimeStamp();\n\n    window.dataLayer.push({\n      event: 'scrollEvent',\n      scrollProgress: `${percent}%`,\n      scrollTime: timeToContentEnd,\n    });\n    analyticsLog(\n      `Scrolled ${percent}% of hidden height ` +\n        `${timeToContentEnd}s after page load.`,\n    );\n\n    hasFired[hasFiredID] = true;\n  }\n}\n\n/**\n * Check the location and track user.\n */\nfunction trackLocation() {\n  const bottomPos = viewableHeight + document.documentElement.scrollTop;\n\n  // If user starts to scroll send an event, currently disabled\n  if (bottomPos > readerLocation && !hasStartScroll) {\n    const timeToScroll = getTimeStamp();\n\n    /* window.dataLayer.push({'event':'scrollEvent',\n       scrollProgress: 'start-scroll',\n       scrollTime: timeToScroll}); */\n    analyticsLog(`Started scrolling ${timeToScroll}s after page load.`);\n\n    hasStartScroll = true;\n  }\n\n  // If user has hit 25%, currently disabled.\n  trackSpecificLocation(bottomPos, 25);\n\n  // If user has hit 50%.\n  trackSpecificLocation(bottomPos, 50);\n\n  // If user has hit 75%, currently disabled.\n  trackSpecificLocation(bottomPos, 75);\n\n  // If user has hit 100%.\n  trackSpecificLocation(bottomPos, 100);\n}\n\n// Track the scrolling and track location\nwindow.addEventListener('scroll', function () {\n  if (timer) {\n    clearTimeout(timer);\n  }\n  // Use a buffer so we don't call trackLocation too often.\n  timer = setTimeout(trackLocation, callBackTime);\n});\n"],
  "mappings": "MAIA,SAASA,KAAgBC,EAAK,CAExB,OAAO,OAAO,iBAAoB,YAEhB,IAAI,gBAAgB,OAAO,SAAS,MAAM,EAC9C,IAAI,WAAW,IAAM,QAEnC,QAAQ,IAAI,yBAAyBA,CAAG,EAAE,CAGhD,CCXA,IAAMC,EAAe,IAGfC,EAAiB,IAGnBC,EAAQ,EACRC,EAAiB,GAMfC,EAAY,EAEZC,EAAiB,OAAO,YACxBC,EAAc,SAAS,KAAK,aAAeF,EAC3CG,EAAoBD,EAAcD,EAGlCG,EAAW,CAAC,EAGZC,EAAY,CAAC,EAGbC,EAAY,IAAI,KAChBC,EAAiBD,EAAU,QAAQ,EAKzC,SAASE,GAAe,CAEtB,OAAO,KAAK,OADQ,IAAI,KAAK,EACE,QAAQ,EAAID,GAAkB,GAAI,CACnE,CAQA,SAASE,EAAsBC,EAAWC,EAAS,CACjD,IAAIC,EAAOP,EAAUM,CAAO,EAE5B,GAAI,CAACC,EAAM,CACT,IAAMC,EAAmBF,EAAU,IACnCC,EAAOT,EAAoBU,EAAmBZ,EAC9CI,EAAUM,CAAO,EAAIC,CACvB,CAEA,IAAME,EAAa,MAAMH,CAAO,GAEhC,GAAI,CAACP,EAASU,CAAU,GAAKJ,GAAaE,EAAM,CAC9C,IAAMG,EAAmBP,EAAa,EAEtC,OAAO,UAAU,KAAK,CACpB,MAAO,cACP,eAAgB,GAAGG,CAAO,IAC1B,WAAYI,CACd,CAAC,EACDC,EACE,YAAYL,CAAO,sBACdI,CAAgB,oBACvB,EAEAX,EAASU,CAAU,EAAI,EACzB,CACF,CAKA,SAASG,GAAgB,CACvB,IAAMP,EAAYT,EAAiB,SAAS,gBAAgB,UAG5D,GAAIS,EAAYb,GAAkB,CAACE,EAAgB,CACjD,IAAMmB,EAAeV,EAAa,EAKlCQ,EAAa,qBAAqBE,CAAY,oBAAoB,EAElEnB,EAAiB,EACnB,CAGAU,EAAsBC,EAAW,EAAE,EAGnCD,EAAsBC,EAAW,EAAE,EAGnCD,EAAsBC,EAAW,EAAE,EAGnCD,EAAsBC,EAAW,GAAG,CACtC,CAGA,OAAO,iBAAiB,SAAU,UAAY,CACxCZ,GACF,aAAaA,CAAK,EAGpBA,EAAQ,WAAWmB,EAAerB,CAAY,CAChD,CAAC",
  "names": ["analyticsLog", "msg", "callBackTime", "readerLocation", "timer", "hasStartScroll", "threshold", "viewableHeight", "totalheight", "totalHiddenHeight", "hasFired", "yPosCache", "startTime", "timeAtPageLoad", "getTimeStamp", "trackSpecificLocation", "bottomPos", "percent", "yPos", "percentAsDecimal", "hasFiredID", "timeToContentEnd", "analyticsLog", "trackLocation", "timeToScroll"]
}
