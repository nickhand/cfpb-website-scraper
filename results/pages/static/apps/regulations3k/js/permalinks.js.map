{
  "version": 3,
  "sources": ["../../../../unprocessed/apps/regulations3k/js/permalinks-utils.js", "../../../../unprocessed/apps/regulations3k/js/permalinks.js"],
  "sourcesContent": ["// Array that tracks paragraph positions\nlet paragraphPositions;\nconst regs3kMainContent = document.querySelector(\n  '.regulations3k #content__main',\n);\nconst regs3kWayfinder = document.querySelector('.o-regulations-wayfinder');\nlet wayfinderOffset = 0;\nif (regs3kWayfinder !== null) {\n  wayfinderOffset = regs3kWayfinder.scrollHeight + 10;\n}\n\nconst wayfinderRegex = {\n  appendixTitle: /Appendix [^\\s]+/,\n  title: /\u00A7 10[0-9].\\.[0-9]*/g,\n  marker: /-/g,\n};\n\n/**\n * scrollY - Get the Y coord of the current viewport. Older browsers don't\n * support `scrollY` so use whichever works.\n * @returns {Function} Browser-supported y offset method.\n */\nconst scrollY = () => window.scrollY || window.pageYOffset;\n\n/**\n * getFirstMatch - Get the first match of a REGEX\n * @param {string} haystack - String to search\n * @param {string} needle - REGEX to search for\n * @returns {string} Matched string or empty string\n */\nconst getFirstMatch = (haystack, needle) => {\n  if (haystack !== null && haystack.match(needle) !== null) {\n    return haystack.match(needle)[0];\n  }\n  return '';\n};\n\n/**\n * getYLocation - Get Y location of provided element on the page.\n * @param {HTMLElement} el - HTML element.\n * @returns {number} Pixel value of vertical page location of element.\n */\nconst getYLocation = (el) => {\n  const elOffset = el.getBoundingClientRect().top;\n  return scrollY() + elOffset - 30;\n};\n\n/**\n * getParagraphPositions - Get an array of all paragraphs with their IDs\n * mapped to their Y position (number of pixels from top of page).\n * @param {NodeList} paragraphs - Nodelist of HTML elements with IDs.\n * @returns {Array} Array of objects w/ paragraph IDs and y positions.\n */\nconst getParagraphPositions = (paragraphs) => {\n  let paragraphPos = [];\n\n  // IE doesn't support `forEach` w/ node lists :/\n  for (let i = 0; i < paragraphs.length; i++) {\n    paragraphPos.push({\n      id: paragraphs[i].id,\n      position: getYLocation(paragraphs[i]),\n    });\n  }\n\n  // Convert it into an array and reverse it\n  paragraphPos = Array.prototype.slice.apply(paragraphPos).reverse();\n\n  return paragraphPos;\n};\n\n/**\n * getCurrentParagraph - Get paragraph closest to viewport's current position.\n * @param {number} currentPosition - Current viewport Y coordinate.\n * @param {Array} paragraphs - List of paragraphs on the page.\n * @returns {string} HTML ID of closest paragraph\n */\nconst getCurrentParagraph = (currentPosition, paragraphs) => {\n  let currentId = null;\n  // We're using a `for` loop so that we can `break` once a match is found\n  for (let i = 0; i < paragraphs.length; i++) {\n    if (currentPosition > paragraphs[i].position) {\n      currentId = paragraphs[i].id;\n      break;\n    }\n  }\n  return currentId;\n};\n\n/**\n * updateUrlHash - Update the page's URL hash w/ the closest paragraph.\n * @returns {undefined} Returned value from window.history.replaceState.\n */\nconst updateUrlHash = () => {\n  const currentParagraph = getCurrentParagraph(\n    scrollY() + wayfinderOffset,\n    paragraphPositions,\n  );\n  // Setting the window state to `.` removes the URL hash\n  const hash = currentParagraph ? `#${currentParagraph}` : '.';\n  return window.history.replaceState(null, null, hash);\n};\n\n/**\n * getCommentMarker - Does the legwork for the more complex comment markers.\n * @param {string} label - data-label of the current paragraph.\n * @returns {string} formatted comment marker.\n */\nconst getCommentMarker = (label) => {\n  let commentedSection;\n  let commentedParagraph;\n  let commentParagraph;\n  let commentedParagraphID = '';\n  let commentParagraphID = '';\n\n  const splitCurrentParagraph = label.split('Interp');\n\n  /* A guard clause just in case any comment paragraphs have an invalid ID that\n     doesn't have 'Interp' in it */\n  if (splitCurrentParagraph.length < 2) {\n    return '';\n  }\n  if (splitCurrentParagraph !== null) {\n    commentedParagraphID = splitCurrentParagraph[0].split('-');\n    commentParagraphID = splitCurrentParagraph[1].split('-');\n  }\n  if (commentedParagraphID !== null) {\n    commentedSection = commentedParagraphID[0];\n    if (commentedSection.match(/[A-Z]/)) {\n      commentedSection = 'app. ' + commentedParagraphID[0];\n      commentedParagraph = '';\n    } else {\n      commentedParagraph = commentedParagraphID.slice(1, -1).join(')(');\n      commentedParagraph = '(' + commentedParagraph + ')';\n    }\n    commentParagraph = commentParagraphID.slice(1).join('.');\n    if (commentParagraph !== '') {\n      commentParagraph = '-' + commentParagraph;\n    }\n  }\n\n  return commentedSection + commentedParagraph + commentParagraph;\n};\n\n/**\n * getWayfinderInfo - process paragraph to create wayfinder.\n * @param {string} label - label of current paragraph.\n * @param {string} sectionTitle - title of current section.\n * @returns {object} object of the values for wayfinder.\n */\nconst getWayfinderInfo = (label, sectionTitle) => {\n  let sectionFormattedTitle;\n  let paragraphMarker;\n\n  /* For interpretations, the wayfinder should look like \"Comment 4(a)-1.iv.A\"\n     Or like \"Comment app. G-1.iv.A\" for interpretations of appendices */\n  if (\n    sectionTitle.indexOf('Comment for ') > -1 ||\n    label.indexOf('Interp') > -1\n  ) {\n    sectionFormattedTitle = 'Comment ';\n    paragraphMarker = getCommentMarker(label);\n  } else if (sectionTitle.indexOf('Appendix ') === 0) {\n    // For appendices, the wayfinder should look like \"Appendix A\"\n    sectionFormattedTitle = getFirstMatch(\n      sectionTitle,\n      wayfinderRegex.appendixTitle,\n    );\n    paragraphMarker = '';\n  } else {\n    // For sections of the main regulation text, the wayfinder should look like \"\u00A7 1026.5(b)(2)(ii)(A)(1)\"\"\n    sectionFormattedTitle = getFirstMatch(sectionTitle, wayfinderRegex.title);\n    if (label !== '') {\n      paragraphMarker = '(' + label.replace(wayfinderRegex.marker, ')(') + ')';\n    }\n  }\n\n  return {\n    paragraphMarker: paragraphMarker,\n    formattedTitle: sectionFormattedTitle,\n  };\n};\n\n/**\n * updateWayfinder - Update the Wayfinder element with current paragraph info.\n * @param {boolean} scroll - if true, the function will scroll the current\n *   paragraph into view.\n * @param {object} wayfinder - wayfinder HTML element.\n * @param {object} mainContent - regs main section HTML element.\n */\nconst updateWayfinder = function (scroll, wayfinder, mainContent) {\n  // We can usually rely on the constants declared above, but just in case...\n  if (typeof wayfinder === 'undefined') wayfinder = regs3kWayfinder;\n  if (typeof mainContent === 'undefined') mainContent = regs3kMainContent;\n\n  if (wayfinder !== null && mainContent !== null) {\n    let paragraphMarker;\n    let sectionFormattedTitle;\n    let wayfinderInfo;\n    const wayfinderLink = wayfinder.querySelector(\n      '.o-regulations-wayfinder__link',\n    );\n    const currentParagraph = getCurrentParagraph(\n      scrollY() + wayfinderOffset,\n      paragraphPositions,\n    );\n\n    if (currentParagraph) {\n      // To avoid hashed IDs, we use data-label for wayfinder text formatting\n      const currentLabel =\n        document.getElementById(currentParagraph).dataset.label;\n      const sectionTitle = wayfinder.dataset.section;\n      wayfinderInfo = getWayfinderInfo(currentLabel, sectionTitle);\n      paragraphMarker = wayfinderInfo.paragraphMarker;\n      sectionFormattedTitle = wayfinderInfo.formattedTitle;\n      mainContent.classList.add('show-wayfinder');\n      wayfinder.style.top = '0px';\n      wayfinderLink.href = '#' + currentParagraph;\n    } else {\n      sectionFormattedTitle = '';\n      paragraphMarker = '';\n      wayfinderLink.href = '#';\n      mainContent.classList.remove('show-wayfinder');\n      wayfinder.style.top = -Math.abs(wayfinderOffset) + 'px';\n    }\n\n    wayfinder.querySelector(\n      '.o-regulations-wayfinder__section-title',\n    ).textContent = sectionFormattedTitle;\n    wayfinder.querySelector('.o-regulations-wayfinder__marker').textContent =\n      paragraphMarker;\n\n    if (scroll === true && window.location.hash.slice(1) !== '') {\n      const elem = document.getElementById(window.location.hash.slice(1));\n      if (elem) {\n        window.scrollTo(0, getYLocation(elem) - wayfinderOffset + 30);\n      }\n    }\n  }\n};\n\n/**\n * updateParagraphPositions - Update the array that tracks paragraph positions.\n * @returns {Array} Array of paragraph positions.\n */\nconst updateParagraphPositions = () => {\n  const paragraphs = document.querySelectorAll('.regdown-block');\n  const visibleParagraphs = [];\n  // IE doesn't support `forEach` w/ node lists\n  for (let i = 0; i < paragraphs.length; i++) {\n    const hiddenParagraphContainer = paragraphs[i].closest('[hidden]');\n    if (!hiddenParagraphContainer) {\n      visibleParagraphs.push(paragraphs[i]);\n    }\n  }\n  paragraphPositions = getParagraphPositions(visibleParagraphs);\n  return paragraphPositions;\n};\n\n/**\n * debounce - Ensure our callbacks fire only after the action has stopped.\n * @param {string} event - Event name.\n * @param {number} delay - Time to wait in milliseconds.\n * @param {Function} cb - Function to be called after action has stopped.\n * @returns {object} Timer\n */\nconst debounce = (event, delay, cb) => {\n  let timeout;\n  window.addEventListener(\n    event,\n    () => {\n      window.clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        cb();\n      }, delay);\n    },\n    false,\n  );\n  return timeout;\n};\n\nexport {\n  debounce,\n  getCommentMarker,\n  getWayfinderInfo,\n  getCurrentParagraph,\n  getFirstMatch,\n  getParagraphPositions,\n  getYLocation,\n  scrollY,\n  updateParagraphPositions,\n  updateUrlHash,\n  updateWayfinder,\n};\n", "/**\n * To auto update the URL's hash as users scroll through regs, we populate an\n * array of objects that maps every paragraph's ID to its Y coordinate on page\n * load. We regenerate this array if the user resizes the window or clicks on\n * an expandable (because both those actions cause paragraphs to move around\n * the page).\n *\n * As users scroll through the page we search the array for the paragraph\n * closest to the top of the viewport and update the URL hash accordingly.\n *\n * The wayfinder element uses the same paragraph IDs (and data-label) to\n * populate its description.\n */\n\nimport {\n  debounce,\n  updateParagraphPositions,\n  updateUrlHash,\n  updateWayfinder,\n} from './permalinks-utils.js';\n\nconst wayfinderLink = document.querySelector('.o-regulations-wayfinder__link');\n\n/**\n * init - Initialize the permalink functionality by cataloging all paragraph\n * locations and adding event listeneres for re-cataloging when necessary.\n */\nconst init = () => {\n  updateParagraphPositions();\n  updateWayfinder(true);\n  if (wayfinderLink !== null) {\n    wayfinderLink.addEventListener('click', (event) => {\n      event.preventDefault();\n      updateWayfinder(true);\n    });\n  }\n\n  debounce('resize', 300, updateParagraphPositions);\n  debounce('click', 300, updateParagraphPositions);\n  debounce('scroll', 100, updateUrlHash);\n  debounce('scroll', 100, updateWayfinder);\n};\n\n// Provide the no-JS experience to browsers without `replaceState`\nif ('replaceState' in window.history) {\n  window.addEventListener('load', init);\n}\n"],
  "mappings": "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",
  "names": ["paragraphPositions", "regs3kMainContent", "regs3kWayfinder", "wayfinderOffset", "wayfinderRegex", "scrollY", "getFirstMatch", "haystack", "needle", "getYLocation", "el", "elOffset", "getParagraphPositions", "paragraphs", "paragraphPos", "i", "getCurrentParagraph", "currentPosition", "currentId", "updateUrlHash", "currentParagraph", "hash", "getCommentMarker", "label", "commentedSection", "commentedParagraph", "commentParagraph", "commentedParagraphID", "commentParagraphID", "splitCurrentParagraph", "getWayfinderInfo", "sectionTitle", "sectionFormattedTitle", "paragraphMarker", "updateWayfinder", "scroll", "wayfinder", "mainContent", "wayfinderInfo", "wayfinderLink", "currentLabel", "elem", "updateParagraphPositions", "visibleParagraphs", "debounce", "event", "delay", "cb", "timeout", "wayfinderLink", "init", "updateParagraphPositions", "updateWayfinder", "event", "debounce", "updateUrlHash"]
}
